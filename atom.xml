<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lrq&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-10T16:36:02.175Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lrq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2020-01-10T15:44:14.194Z</published>
    <updated>2020-01-10T16:36:02.175Z</updated>
    
    <content type="html"><![CDATA[<p>#Java虚拟机——自动内存管理<br>##第二章 Java内存区域与内存溢出异常</p><hr><p>###2.2 运行时数据区域<br>####2.2.2 Java虚拟机栈（VM Stack）</p><ul><li>Java虚拟机栈是<strong>线程私有的</strong>。</li><li>虚拟机栈的“栈”更多情况下指的是其<code>局部变量表</code>部分。</li><li>局部变量表中存放了编译期可知的Java虚拟机基本数据类型(int, long, double…)，它们以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个</li><li>StackOverflowError异常：线程请求的<strong>栈深度大于虚拟机所允许的深度</strong>。<br>OutOfMemoryError异常：若Java虚拟机栈空间可以动态扩展，<strong>栈扩展时无法申请到足够的内存时发生</strong>。<blockquote><p><strong>[注]虚拟机真正使用多大内存空间（一个slot占用32bit或64bit）来实现一个变量槽，这是完全由具体的虚拟机自行决定的事情。</strong></p></blockquote></li></ul><hr><p>####2.2.3 本地方法栈（Native Method Stacks）</p><ul><li>与VM Stack发挥的作用非常相似，VM Stack为虚拟机执行Java方法（字节码）服务，本地方法则是为本地方法（Native）服务</li></ul><hr><p>####2.2.4 Java堆（Java Heap）</p><ul><li>为所有Java线程共享的一片区域</li><li>几乎所有对象实例都在堆中分配内存</li><li>是垃圾收集器管理的内存区域，因此也被称为<code>GC堆(Garbage Collected Heap)</code></li><li>Java堆既可以被实现成固定大小的，也可以是可扩展的。在当前主流Java虚拟机中都是按照可扩展来实现的（通过-Xmx和-Xms设定）。<strong>如果Java堆中没有内存完成实例分配，并且堆再也无法扩展时，Java虚拟机将会抛出OutOfMemoryError异常</strong></li></ul><hr><p>####2.2.5 方法区（Method Area）（非堆）</p><ul><li>为所有Java线程共享的内存区域</li><li>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，</li><li>一般方法区不进行内存回收，若回收，主要是针对常量池的回收和堆类型的卸载，但结果往往比较难令人满意，尤其是堆类型的卸载，条件十分苛刻（但是还是有必要的）。</li><li><blockquote><p>《Java虚拟机规范》规定，如果方法去无法满足新的内存分配需求，将抛出OutOfMemoryError异常</p></blockquote></li></ul><hr><p>####2.2.6 运行时常量池（Runtime Constant Pool）</p><ul><li>是方法区的一部分</li><li>Class文件中除了有<strong>类的模板、字段、方法、接口等描述信息外</strong>，还有一项信息是<code>常量池表(Constant Pool Table)</code>，用于存放编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载之后存放到方法区的运行时常量池中。</li><li>与Class文件常量池的区别：运行时常量池具备动态性，Java语言的常量不一定只有编译期才能产生，并非预置入Class文件中的常量池的内容才能进入运行时常量池，<strong>运行期间也可以将新的常量放入池中</strong>。</li><li>既然RCP是方法区的一部分，因此常量池无法再申请到内存时，会抛出OutOfMemoryError异常</li></ul><hr><p>####2.2.7 直接内存（Direct Memory）</p><ul><li>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分的内存频繁的使用，也可能导致OutOfMemoryError异常出现。</li><li>JDK 1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#Java虚拟机——自动内存管理&lt;br&gt;##第二章 Java内存区域与内存溢出异常&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;###2.2 运行时数据区域&lt;br&gt;####2.2.2 Java虚拟机栈（VM Stack）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java虚拟机栈是&lt;strong&gt;线程私有的&lt;
      
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>mybatis环境搭建</title>
    <link href="http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-01-10T03:21:05.000Z</published>
    <updated>2020-01-10T15:40:34.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis环境搭建"><a href="#mybatis环境搭建" class="headerlink" title="mybatis环境搭建"></a>mybatis环境搭建</h1><hr><h3 id="mybatis环境搭建步骤"><a href="#mybatis环境搭建步骤" class="headerlink" title="mybatis环境搭建步骤"></a><font color="blue">mybatis环境搭建步骤</font></h3><ol><li>创建maven工程并导入坐标</li><li>创建实体类和dao接口</li><li>创建mybatis的主配置文件<code>SqlMapConfig.xml</code></li><li>创建映射配置文件<code>IUserDao.xml</code></li></ol><hr><h3 id="mybatis环境搭建注意事项"><a href="#mybatis环境搭建注意事项" class="headerlink" title="mybatis环境搭建注意事项"></a><font color="blue">mybatis环境搭建注意事项</font></h3><ol><li>创建<code>IUserDao.xml</code> 和 <code>IUserDao.java</code>时名称是为了和我们之前的知识保持一致。在mybatis中它把持久层的操作接口名称和映射文件叫做<code>Mapper</code>。因此 <code>IUserDao</code> 和 <code>IUserMapper</code>是一样的</li><li>在<code>IntelliJ Idea</code>中创建目录的时候，它和包是不一样的。包在创建时，<code>com.lrq.dao</code>是<strong>三级结构</strong>，但目录在创建时，是<strong>一级结构</strong></li><li><strong>mybatis的映射配置文件位置必须和<code>dao</code>接口的包结构相同</strong>（因此我们需要分三级创建目录，保证<code>IUserMapper(Dao).xml</code>文件所在结构和<code>Dao.java</code>所在结构相同）</li><li>映射文件的mapper标签的<code>namspace</code>属性的取值必须是<code>dao</code>接口的<strong>全限定类名</strong></li><li>映射配置文件的操作配置（select或其他)，id的属性取值必须是dao接口的<strong>方法名</strong></li></ol><p><strong>当我们遵循了3, 4, 5点之后，在开发中就无须再去写dao的实现类</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis环境搭建&quot;&gt;&lt;a href=&quot;#mybatis环境搭建&quot; class=&quot;headerlink&quot; title=&quot;mybatis环境搭建&quot;&gt;&lt;/a&gt;mybatis环境搭建&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;mybatis环境搭建步骤&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>小鸡你别生气了，大狗错了啵啵啵</title>
    <link href="http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/"/>
    <id>http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/</id>
    <published>2020-01-08T17:00:27.000Z</published>
    <updated>2020-01-08T17:00:27.359Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Third</title>
    <link href="http://yoursite.com/2020/01/09/Third/"/>
    <id>http://yoursite.com/2020/01/09/Third/</id>
    <published>2020-01-08T16:53:00.000Z</published>
    <updated>2020-01-08T16:53:00.208Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
