<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lrq&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-11T16:49:58.027Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lrq</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java内存区域与内存溢出异常day02</title>
    <link href="http://yoursite.com/2020/01/12/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day02/"/>
    <id>http://yoursite.com/2020/01/12/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day02/</id>
    <published>2020-01-11T16:12:03.169Z</published>
    <updated>2020-01-11T16:49:58.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机——自动内存管理"><a href="#Java虚拟机——自动内存管理" class="headerlink" title="Java虚拟机——自动内存管理"></a>Java虚拟机——自动内存管理</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><hr><h3 id="2-3-HotSpot-虚拟机对象探秘"><a href="#2-3-HotSpot-虚拟机对象探秘" class="headerlink" title="2.3 HotSpot 虚拟机对象探秘"></a>2.3 HotSpot 虚拟机对象探秘</h3><h4 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h4><p><strong><font size=4 color='red'>在JVM中，一个对象（普通JAVA对象）被创建过程如下：</font></strong></p><ol><li>当Java虚拟机遇到一条字节码new指令时，首先检查此参数是否能在<code>常量池</code>中定位到一个类的符号引用</li><li>检查符号引用代表的类是否已经被加载、解析和初始化过，若没有则执行类加载过程。</li><li>给新生对象在Java堆中分配内存</li><li>并发时采用CAS与失败重试来保证分配内存时的线程安全。</li><li>对将生成的对象进行必要的设置（哪个类的实例，如何找到类的Meta Data，对象的HashCode等）</li></ol><p>&emsp;&emsp;Java堆如果是<code>绝对规整</code>的，即通过一个指针将空闲内存和可用内存分开，那么则通过<code>指针碰撞(Bump The Pointer)</code>来分配内存。如果Java堆是不规整的，即空闲内存和可用内存交错在一起，那么则采用<code>空闲列表(Free List)</code>来分配内存。<br><strong>[注]选择哪种方式是由Java堆是否规整来决定的，而Java堆是否规整又由GC是否带有<code>空间压缩整理(Compact)</code>的能力决定。因此，当使用Serial, ParNew等带压缩整理的收集器，则采用指针碰撞；当使用CMS这种基于<code>清除(Sweep)</code>算法的收集器时，理论上就只能采用复杂的空闲列表来分配内存。</strong></p><p>&emsp;&emsp;并发时，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，因此<br><strong><font size=4 color='red'>在并发情况下，有两种方案可以保证线程安全：</font></strong></p><ol><li>需要使用<code>CAS(Compare and Swap)</code>配上<code>失败重试</code>的方式来保证更新操作的原子性</li><li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存即<code>TLAB(Thread Local Allocation Buffer)</code>，哪个线程要分配内存，就在哪个线程的本地缓冲区分配，只用本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。</li></ol><p>在虚拟机的视角中，对象已经建立完成，而在Java程序的视角来看，对象创建才刚刚开始——构造函数，Class文件中的&lt;init&gt;()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说new指令之后就会接着执行&lt;init&gt;()方法，按程序员的意愿对对象进行初始化。</p><hr><h4 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h4><p><strong><font size=4 color='red'>在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分：</font></strong></p><ol><li>对象头(Header)</li><li>实例数据(Instance Data)</li><li>对齐填充(Padding)</li></ol><p>首先，对于对象头包含了两部分信息。</p><ol><li>用于存储对象自身的运行时数据<br>如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分在32位和64位虚拟机中分别为32bit和64bit，称为<code>Mark Word</code></li><li>类型指针<br>类型指针即对象指向它类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例（并不一定所有虚拟机实现都保留此指针）。</li><li>长度数据（Java数组）<br>若对象是一个Java数组，则在对象头中还必须有一块记录数组长度的数据。</li></ol><p>实例数据是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型字段内容，无论是从父类继承下来的，还是在子类中定义的。</p><p>对其填充并不是必然存在的，也没有特别的含义，仅仅起占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是任何对象的大小都必须是8字节的整数倍。（对象头已经被精心设计成正好是8字节的倍数）</p><hr><h4 id="2-3-3对象的访问定位"><a href="#2-3-3对象的访问定位" class="headerlink" title="2.3.3对象的访问定位"></a>2.3.3对象的访问定位</h4><p>创建对象自然是为了后续使用该对象。</p><blockquote><p>Java虚拟机规范称，Java程序会通过栈上的reference数据来操作堆上的具体对象。</p></blockquote><p>由于知识定义了reference是一个指向对象的引用，并没有定义这个引用还应该通过什么方式区定位、访问堆中的具体位置，因此实现由虚拟机而定。<br><strong><font size=4 color='red'>主流的实现方式有以下两种：</font></strong><br>1.句柄访问<br>Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例与类型数据各自具体的地址信息<br><strong>优势：reference中存储的是稳定句柄地址，在对象被移动时指挥改变句柄中的实例数据指针，refenence本身不需要更改</strong><br>2.直接指针访问<br>Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果知识访问对象本身的话，就不需要多一次间接访问的开销。<br><strong>优势：速度更快，节省了一次指针定位的时间开销</strong><br><strong>[注]在HotSpot虚拟机中，主要使用<code>直接指针访问</code>的方式进行对象访问（有例外情况，如果使用了Shenandoah收集器可能会有一次额外的转发），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况十分常见</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java虚拟机——自动内存管理&quot;&gt;&lt;a href=&quot;#Java虚拟机——自动内存管理&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机——自动内存管理&quot;&gt;&lt;/a&gt;Java虚拟机——自动内存管理&lt;/h1&gt;&lt;h2 id=&quot;第二章-Java内存区域与
      
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常day01</title>
    <link href="http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day01/"/>
    <id>http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day01/</id>
    <published>2020-01-10T15:44:14.194Z</published>
    <updated>2020-01-11T16:50:05.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机——自动内存管理"><a href="#Java虚拟机——自动内存管理" class="headerlink" title="Java虚拟机——自动内存管理"></a>Java虚拟机——自动内存管理</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><hr><h3 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h3><h4 id="2-2-2-Java虚拟机栈（VM-Stack）"><a href="#2-2-2-Java虚拟机栈（VM-Stack）" class="headerlink" title="2.2.2 Java虚拟机栈（VM Stack）"></a>2.2.2 Java虚拟机栈（VM Stack）</h4><ul><li>Java虚拟机栈是<strong>线程私有的</strong>。</li><li>虚拟机栈的“栈”更多情况下指的是其<code>局部变量表</code>部分。</li><li>局部变量表中存放了编译期可知的Java虚拟机基本数据类型(int, long, double…)，它们以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个</li><li>StackOverflowError异常：线程请求的<strong>栈深度大于虚拟机所允许的深度</strong>。<br>OutOfMemoryError异常：若Java虚拟机栈空间可以动态扩展，<strong>栈扩展时无法申请到足够的内存时发生</strong>。<blockquote><p><strong>[注]虚拟机真正使用多大内存空间（一个slot占用32bit或64bit）来实现一个变量槽，这是完全由具体的虚拟机自行决定的事情。</strong></p></blockquote></li></ul><hr><h4 id="2-2-3-本地方法栈（Native-Method-Stacks）"><a href="#2-2-3-本地方法栈（Native-Method-Stacks）" class="headerlink" title="2.2.3 本地方法栈（Native Method Stacks）"></a>2.2.3 本地方法栈（Native Method Stacks）</h4><ul><li>与VM Stack发挥的作用非常相似，VM Stack为虚拟机执行Java方法（字节码）服务，本地方法则是为本地方法（Native）服务</li></ul><hr><h4 id="2-2-4-Java堆（Java-Heap）"><a href="#2-2-4-Java堆（Java-Heap）" class="headerlink" title="2.2.4 Java堆（Java Heap）"></a>2.2.4 Java堆（Java Heap）</h4><ul><li>为所有Java线程共享的一片区域</li><li>几乎所有对象实例都在堆中分配内存</li><li>是垃圾收集器管理的内存区域，因此也被称为<code>GC堆(Garbage Collected Heap)</code></li><li>Java堆既可以被实现成固定大小的，也可以是可扩展的。在当前主流Java虚拟机中都是按照可扩展来实现的（通过-Xmx和-Xms设定）。<strong>如果Java堆中没有内存完成实例分配，并且堆再也无法扩展时，Java虚拟机将会抛出OutOfMemoryError异常</strong></li></ul><hr><h4 id="2-2-5-方法区（Method-Area）（非堆）"><a href="#2-2-5-方法区（Method-Area）（非堆）" class="headerlink" title="2.2.5 方法区（Method Area）（非堆）"></a>2.2.5 方法区（Method Area）（非堆）</h4><ul><li>为所有Java线程共享的内存区域</li><li>用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据，</li><li>一般方法区不进行内存回收，若回收，主要是针对常量池的回收和堆类型的卸载，但结果往往比较难令人满意，尤其是堆类型的卸载，条件十分苛刻（但是还是有必要的）。</li><li><blockquote><p>《Java虚拟机规范》规定，如果方法去无法满足新的内存分配需求，将抛出OutOfMemoryError异常</p></blockquote></li></ul><hr><h4 id="2-2-6-运行时常量池（Runtime-Constant-Pool）"><a href="#2-2-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="2.2.6 运行时常量池（Runtime Constant Pool）"></a>2.2.6 运行时常量池（Runtime Constant Pool）</h4><ul><li>是方法区的一部分</li><li>Class文件中除了有<strong>类的模板、字段、方法、接口等描述信息外</strong>，还有一项信息是<code>常量池表(Constant Pool Table)</code>，用于存放编译器生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在类加载之后存放到方法区的运行时常量池中。</li><li>与Class文件常量池的区别：运行时常量池具备动态性，Java语言的常量不一定只有编译期才能产生，并非预置入Class文件中的常量池的内容才能进入运行时常量池，<strong>运行期间也可以将新的常量放入池中</strong>。</li><li>既然RCP是方法区的一部分，因此常量池无法再申请到内存时，会抛出OutOfMemoryError异常</li></ul><hr><h4 id="2-2-7-直接内存（Direct-Memory）"><a href="#2-2-7-直接内存（Direct-Memory）" class="headerlink" title="2.2.7 直接内存（Direct Memory）"></a>2.2.7 直接内存（Direct Memory）</h4><ul><li>并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分的内存频繁的使用，也可能导致OutOfMemoryError异常出现。</li><li>JDK 1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java虚拟机——自动内存管理&quot;&gt;&lt;a href=&quot;#Java虚拟机——自动内存管理&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机——自动内存管理&quot;&gt;&lt;/a&gt;Java虚拟机——自动内存管理&lt;/h1&gt;&lt;h2 id=&quot;第二章-Java内存区域与
      
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>mybatis环境搭建</title>
    <link href="http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-01-10T03:21:05.000Z</published>
    <updated>2020-01-10T15:40:34.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis环境搭建"><a href="#mybatis环境搭建" class="headerlink" title="mybatis环境搭建"></a>mybatis环境搭建</h1><hr><h3 id="mybatis环境搭建步骤"><a href="#mybatis环境搭建步骤" class="headerlink" title="mybatis环境搭建步骤"></a><font color="blue">mybatis环境搭建步骤</font></h3><ol><li>创建maven工程并导入坐标</li><li>创建实体类和dao接口</li><li>创建mybatis的主配置文件<code>SqlMapConfig.xml</code></li><li>创建映射配置文件<code>IUserDao.xml</code></li></ol><hr><h3 id="mybatis环境搭建注意事项"><a href="#mybatis环境搭建注意事项" class="headerlink" title="mybatis环境搭建注意事项"></a><font color="blue">mybatis环境搭建注意事项</font></h3><ol><li>创建<code>IUserDao.xml</code> 和 <code>IUserDao.java</code>时名称是为了和我们之前的知识保持一致。在mybatis中它把持久层的操作接口名称和映射文件叫做<code>Mapper</code>。因此 <code>IUserDao</code> 和 <code>IUserMapper</code>是一样的</li><li>在<code>IntelliJ Idea</code>中创建目录的时候，它和包是不一样的。包在创建时，<code>com.lrq.dao</code>是<strong>三级结构</strong>，但目录在创建时，是<strong>一级结构</strong></li><li><strong>mybatis的映射配置文件位置必须和<code>dao</code>接口的包结构相同</strong>（因此我们需要分三级创建目录，保证<code>IUserMapper(Dao).xml</code>文件所在结构和<code>Dao.java</code>所在结构相同）</li><li>映射文件的mapper标签的<code>namspace</code>属性的取值必须是<code>dao</code>接口的<strong>全限定类名</strong></li><li>映射配置文件的操作配置（select或其他)，id的属性取值必须是dao接口的<strong>方法名</strong></li></ol><p><strong>当我们遵循了3, 4, 5点之后，在开发中就无须再去写dao的实现类</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis环境搭建&quot;&gt;&lt;a href=&quot;#mybatis环境搭建&quot; class=&quot;headerlink&quot; title=&quot;mybatis环境搭建&quot;&gt;&lt;/a&gt;mybatis环境搭建&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;mybatis环境搭建步骤&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="java学习" scheme="http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>小鸡你别生气了，大狗错了啵啵啵</title>
    <link href="http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/"/>
    <id>http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/</id>
    <published>2020-01-08T17:00:27.000Z</published>
    <updated>2020-01-08T17:00:27.359Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Third</title>
    <link href="http://yoursite.com/2020/01/09/Third/"/>
    <id>http://yoursite.com/2020/01/09/Third/</id>
    <published>2020-01-08T16:53:00.000Z</published>
    <updated>2020-01-08T16:53:00.208Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
