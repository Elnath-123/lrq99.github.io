{"meta":{"title":"Lrq's blogs","subtitle":"","description":"","author":"Lrq","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-01-08T14:54:51.000Z","updated":"2020-01-08T15:13:35.652Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-08T14:53:30.000Z","updated":"2020-01-08T14:54:37.387Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java内存区域与内存溢出异常day02","slug":"JVM自动内存管理day02","date":"2020-01-11T16:12:03.169Z","updated":"2020-01-11T16:49:58.027Z","comments":true,"path":"2020/01/12/JVM自动内存管理day02/","link":"","permalink":"http://yoursite.com/2020/01/12/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day02/","excerpt":"","text":"Java虚拟机——自动内存管理第二章 Java内存区域与内存溢出异常 2.3 HotSpot 虚拟机对象探秘2.3.1 对象的创建在JVM中，一个对象（普通JAVA对象）被创建过程如下： 当Java虚拟机遇到一条字节码new指令时，首先检查此参数是否能在常量池中定位到一个类的符号引用 检查符号引用代表的类是否已经被加载、解析和初始化过，若没有则执行类加载过程。 给新生对象在Java堆中分配内存 并发时采用CAS与失败重试来保证分配内存时的线程安全。 对将生成的对象进行必要的设置（哪个类的实例，如何找到类的Meta Data，对象的HashCode等） &emsp;&emsp;Java堆如果是绝对规整的，即通过一个指针将空闲内存和可用内存分开，那么则通过指针碰撞(Bump The Pointer)来分配内存。如果Java堆是不规整的，即空闲内存和可用内存交错在一起，那么则采用空闲列表(Free List)来分配内存。[注]选择哪种方式是由Java堆是否规整来决定的，而Java堆是否规整又由GC是否带有空间压缩整理(Compact)的能力决定。因此，当使用Serial, ParNew等带压缩整理的收集器，则采用指针碰撞；当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用复杂的空闲列表来分配内存。 &emsp;&emsp;并发时，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，因此在并发情况下，有两种方案可以保证线程安全： 需要使用CAS(Compare and Swap)配上失败重试的方式来保证更新操作的原子性 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存即TLAB(Thread Local Allocation Buffer)，哪个线程要分配内存，就在哪个线程的本地缓冲区分配，只用本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。 在虚拟机的视角中，对象已经建立完成，而在Java程序的视角来看，对象创建才刚刚开始——构造函数，Class文件中的&lt;init&gt;()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说new指令之后就会接着执行&lt;init&gt;()方法，按程序员的意愿对对象进行初始化。 2.3.2 对象的内存布局在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分： 对象头(Header) 实例数据(Instance Data) 对齐填充(Padding) 首先，对于对象头包含了两部分信息。 用于存储对象自身的运行时数据如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分在32位和64位虚拟机中分别为32bit和64bit，称为Mark Word 类型指针类型指针即对象指向它类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例（并不一定所有虚拟机实现都保留此指针）。 长度数据（Java数组）若对象是一个Java数组，则在对象头中还必须有一块记录数组长度的数据。 实例数据是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型字段内容，无论是从父类继承下来的，还是在子类中定义的。 对其填充并不是必然存在的，也没有特别的含义，仅仅起占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是任何对象的大小都必须是8字节的整数倍。（对象头已经被精心设计成正好是8字节的倍数） 2.3.3对象的访问定位创建对象自然是为了后续使用该对象。 Java虚拟机规范称，Java程序会通过栈上的reference数据来操作堆上的具体对象。 由于知识定义了reference是一个指向对象的引用，并没有定义这个引用还应该通过什么方式区定位、访问堆中的具体位置，因此实现由虚拟机而定。主流的实现方式有以下两种：1.句柄访问Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例与类型数据各自具体的地址信息优势：reference中存储的是稳定句柄地址，在对象被移动时指挥改变句柄中的实例数据指针，refenence本身不需要更改2.直接指针访问Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果知识访问对象本身的话，就不需要多一次间接访问的开销。优势：速度更快，节省了一次指针定位的时间开销[注]在HotSpot虚拟机中，主要使用直接指针访问的方式进行对象访问（有例外情况，如果使用了Shenandoah收集器可能会有一次额外的转发），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况十分常见","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Java内存区域与内存溢出异常day01","slug":"JVM自动内存管理day01","date":"2020-01-10T15:44:14.194Z","updated":"2020-01-11T16:50:05.273Z","comments":true,"path":"2020/01/10/JVM自动内存管理day01/","link":"","permalink":"http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day01/","excerpt":"","text":"Java虚拟机——自动内存管理第二章 Java内存区域与内存溢出异常 2.2 运行时数据区域2.2.2 Java虚拟机栈（VM Stack） Java虚拟机栈是线程私有的。 虚拟机栈的“栈”更多情况下指的是其局部变量表部分。 局部变量表中存放了编译期可知的Java虚拟机基本数据类型(int, long, double…)，它们以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个 StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度。OutOfMemoryError异常：若Java虚拟机栈空间可以动态扩展，栈扩展时无法申请到足够的内存时发生。 [注]虚拟机真正使用多大内存空间（一个slot占用32bit或64bit）来实现一个变量槽，这是完全由具体的虚拟机自行决定的事情。 2.2.3 本地方法栈（Native Method Stacks） 与VM Stack发挥的作用非常相似，VM Stack为虚拟机执行Java方法（字节码）服务，本地方法则是为本地方法（Native）服务 2.2.4 Java堆（Java Heap） 为所有Java线程共享的一片区域 几乎所有对象实例都在堆中分配内存 是垃圾收集器管理的内存区域，因此也被称为GC堆(Garbage Collected Heap) Java堆既可以被实现成固定大小的，也可以是可扩展的。在当前主流Java虚拟机中都是按照可扩展来实现的（通过-Xmx和-Xms设定）。如果Java堆中没有内存完成实例分配，并且堆再也无法扩展时，Java虚拟机将会抛出OutOfMemoryError异常 2.2.5 方法区（Method Area）（非堆） 为所有Java线程共享的内存区域 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据， 一般方法区不进行内存回收，若回收，主要是针对常量池的回收和堆类型的卸载，但结果往往比较难令人满意，尤其是堆类型的卸载，条件十分苛刻（但是还是有必要的）。 《Java虚拟机规范》规定，如果方法去无法满足新的内存分配需求，将抛出OutOfMemoryError异常 2.2.6 运行时常量池（Runtime Constant Pool） 是方法区的一部分 Class文件中除了有类的模板、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载之后存放到方法区的运行时常量池中。 与Class文件常量池的区别：运行时常量池具备动态性，Java语言的常量不一定只有编译期才能产生，并非预置入Class文件中的常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中。 既然RCP是方法区的一部分，因此常量池无法再申请到内存时，会抛出OutOfMemoryError异常 2.2.7 直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分的内存频繁的使用，也可能导致OutOfMemoryError异常出现。 JDK 1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"mybatis环境搭建","slug":"day01_mybatis环境搭建","date":"2020-01-10T03:21:05.000Z","updated":"2020-01-10T15:40:34.829Z","comments":true,"path":"2020/01/10/day01_mybatis环境搭建/","link":"","permalink":"http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"mybatis环境搭建 mybatis环境搭建步骤 创建maven工程并导入坐标 创建实体类和dao接口 创建mybatis的主配置文件SqlMapConfig.xml 创建映射配置文件IUserDao.xml mybatis环境搭建注意事项 创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。在mybatis中它把持久层的操作接口名称和映射文件叫做Mapper。因此 IUserDao 和 IUserMapper是一样的 在IntelliJ Idea中创建目录的时候，它和包是不一样的。包在创建时，com.lrq.dao是三级结构，但目录在创建时，是一级结构 mybatis的映射配置文件位置必须和dao接口的包结构相同（因此我们需要分三级创建目录，保证IUserMapper(Dao).xml文件所在结构和Dao.java所在结构相同） 映射文件的mapper标签的namspace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置（select或其他)，id的属性取值必须是dao接口的方法名 当我们遵循了3, 4, 5点之后，在开发中就无须再去写dao的实现类","categories":[{"name":"java学习","slug":"java学习","permalink":"http://yoursite.com/categories/java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"小鸡你别生气了，大狗错了啵啵啵","slug":"小鸡你别生气了，大狗错了啵啵啵","date":"2020-01-08T17:00:27.000Z","updated":"2020-01-08T17:00:27.359Z","comments":true,"path":"2020/01/09/小鸡你别生气了，大狗错了啵啵啵/","link":"","permalink":"http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Third","slug":"Third","date":"2020-01-08T16:53:00.000Z","updated":"2020-01-08T16:53:00.208Z","comments":true,"path":"2020/01/09/Third/","link":"","permalink":"http://yoursite.com/2020/01/09/Third/","excerpt":"","text":"","categories":[],"tags":[]}]}