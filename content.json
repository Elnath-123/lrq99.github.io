{"meta":{"title":"Lrq's blogs","subtitle":"","description":"","author":"Lrq","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-01-08T14:54:51.000Z","updated":"2020-01-08T15:13:35.652Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-01-08T14:53:30.000Z","updated":"2020-01-08T14:54:37.387Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"无重复字符的最长子串","slug":"leetcode_无重复字符的最长子串","date":"2020-02-04T06:17:54.951Z","updated":"2020-02-04T07:28:29.046Z","comments":true,"path":"2020/02/04/leetcode_无重复字符的最长子串/","link":"","permalink":"http://yoursite.com/2020/02/04/leetcode_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度[注]子串是连续的，子序列是可以不连续的 例如: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 求解方法维护一个滑动窗口(Sliding Window)，窗口中保存不相同的字符串，窗口的大小即当前最长的不重复子串 &emsp;&emsp;如图，当前窗口大小为3。当j指向第四个字符元素时，若窗口继续增大，则index=1处的元素与index=4处的元素重复，不符合。因此窗口的下界应该增大（i增大）。&emsp;&emsp;i应该增长多少，才能保证算法的效率尽可能高呢?&emsp;&emsp;我们发现，index=1和index=4处的字符元素相同，它们之间所构成的最大窗口的大小，一定小于等于当前的窗口大小（下图为等于当前窗口大小的情况）。因此，我们可以将i直接增长到index=1字符的下一处，即index=2。 &emsp;&emsp;当然，有时也会遇到以下情况。 &emsp;&emsp;j = 3时，由于有两个c相同，故i从i = 0跳至i = 2。j = 4时，此时又发现index = 0处的字符元素与index = 4处的字符元素相同，可此时i &gt; 前一个字符的index(index = 0)。这种情况下i不能跳到index = 1处。&emsp;&emsp;故，i在进行跳转时，i = max(前一个相同字符的索引, i) 实现思路&emsp;&emsp;为了保存字符的索引，我们采用STL库中的map。Java可采用HashMap，原理是相同的。j在遍历整个字符串时，需要不停的更新/插入新的Entry对（不存在当前元素则插入，存在当前元素则更新）。进行更新是为了保留最新的字符索引位置，以便字符跳转时可以跳转到正确的位置。 实现代码(C++)12345678910111213141516171819int lengthOfLongestSubstring(string s) &#123; /* 保存字符的索引 */ map&lt;char, int&gt; idx; int ans = 0; for(int i = 0, j = 0; j &lt; s.size(); j++)&#123; /* 查找索引表中是否在j之前存在相同元素 */ if(idx.find(s[j]) != idx.end())&#123; /* 若存在，并且i比找到的那个索引小，那么就可以让i跳转到那个索引的下一个位置 */ i = max(idx[s[j]] + 1, i); &#125; /* 更新当前窗口的大小，j - 1 + 1即当前窗口大小 */ ans = max(j - i + 1, ans); /* 不断更新/插入字符索引位置 */ idx[s[j]] = j; &#125; return ans; &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/categories/Algorithm/"}],"tags":[{"name":"Sliding Window","slug":"Sliding-Window","permalink":"http://yoursite.com/tags/Sliding-Window/"}]},{"title":"JVM垃圾收集器小结（一）","slug":"JVM垃圾收集器小结（一）","date":"2020-01-23T08:08:51.936Z","updated":"2020-01-23T09:15:29.776Z","comments":true,"path":"2020/01/23/JVM垃圾收集器小结（一）/","link":"","permalink":"http://yoursite.com/2020/01/23/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"JVM垃圾收集器小结（一）一、可达性分析算法&emsp;&emsp;在可达性分析算法中一个核心概念是 GC Root。&emsp;&emsp;垃圾收集器通过从GC Root对象开始，根据引用关系，向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)。如果某个对象到GC Root是有引用链相连的，那么这个对象就是可达的。&emsp;&emsp;在垃圾收集执行过程中，第一步所要做的事情就是初始标记，即进行可达性分析。所有与GC Root之间有引用链相连的对象，都会被标记，最终不会被清理。则其余的可能被清理。（在并发下，可能还需要重新标记，以保证标记的正确性） &emsp;&emsp;什么对象可以被当作GC Root呢? 虚拟机栈中的引用 方法区中，类静态属性引用的对象 方法区中，常量引用的对象(字符串常量池中的引用) 本地方法栈中JNI(Native 方法)引用的对象 运行时常量池中引用的对象 JVM内部引用，如基本数据类型（int, char…）对应的Class对象、系统类加载器、常驻的异常对象(NullPointException, OutOfMemoryException…) JMXBean, JVMTI中注册的回调 在Minor GC发生时，由于存在老年代对新生代的跨代引用，因此有些从GC Root搜索后不可达的对象可能被老年代引用，因此该新生代不需被清理。所以应该在GC Root中来扫描所有老年代对象，但是这样的话开销太大，因此引入了记忆集。在记忆集中，记录了老年代对新生代的跨代引用，因此无须将所有老年代对象加入GC Root，只需将记忆集中老年代对象加入GC Root 在Old GC发生时，需要将所有年轻代对象加入GC Root进行可达性分析以解决跨代引用的问题。这是因为新生代不稳定，引用变化十分频繁，因此更新记忆集的开销会比较大。 二、G1与CMS的比较 G1划分Region，在逻辑上的分代，不要求物理上分代，而CMS是逻辑和物理都分代。 G1在回收阶段采用标记-整理算法，而CMS采用标记-清除算法。这也说明了CMS在回收阶段可以与用户线程并发而G1需要STW。 G1可面对堆内存任何部分组成回收集合（Collection Set），即Mixed GC，并且通过设定最大停顿时间来选择收益较高的Region回收。而CMS分old GC和young/minor GC，每次收集都收集所有的垃圾。 G1在重新标记阶段采用STAB（原始快照）方法，而CMS采用增量更新方法。 G1的优点：没有内部碎片，可指定最大停顿时间，按收益确定回收集G1的缺点：内存占用高，因为每一个Region都需要一份卡表。而CMS只有一份卡表（记录老年代到新生代的引用）；执行负载高，因为G1不但需要写后屏障来更新卡表，还需要写前屏障实现STAB跟踪并发时的指针变化，以减少并发标记和重新标记阶段的消耗。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"},{"name":"垃圾收集器","slug":"垃圾收集器","permalink":"http://yoursite.com/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"}]},{"title":"构造器调用顺序","slug":"构造器调用顺序","date":"2020-01-22T06:30:11.799Z","updated":"2020-01-22T06:40:16.242Z","comments":true,"path":"2020/01/22/构造器调用顺序/","link":"","permalink":"http://yoursite.com/2020/01/22/%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"Java构造器调用顺序继承关系图：Meal-&gt;Lunch-&gt;PortableLunch-&gt;SandWich 递归的调用基类构造器。首先构造继承结构中的根类，然后是下一层导出类，直到当前类 按声明顺序调用成员的初始化方法 调用导出类构造器的主体12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.sql.SQLOutput;class Meal&#123; Apple apple = new Apple(); Meal()&#123; System.out.println(\"Meal()\"); &#125;&#125;class Bread&#123; Bread()&#123; System.out.println(\"Bread()\"); &#125;&#125;class Apple&#123; Apple()&#123; System.out.println(\"Apple()\"); &#125;&#125;class Banana&#123; Banana() &#123; System.out.println(\"Banana()\"); &#125;&#125;class Cheese&#123; Cheese()&#123; System.out.println(\"Cheese()\"); &#125;&#125;class Lettuce&#123; Lettuce()&#123; System.out.println(\"Lettuce()\"); &#125;&#125;class Lunch extends Meal&#123; Cheese cheese = new Cheese(); Lunch()&#123; System.out.println(\"Lunch()\"); &#125;&#125;class PortableLunch extends Lunch&#123; Lettuce lettuce = new Lettuce(); PortableLunch()&#123; System.out.println(\"PortableLunch()\"); &#125;&#125;public class SandWich extends PortableLunch&#123; private Banana banana = new Banana(); public SandWich()&#123; System.out.println(\"SandWich()\"); &#125; public static void main(String[] args) &#123; new SandWich(); &#125;&#125; 输出顺序为12345678Apple() &#x2F;&#x2F;Meal类成员apple初始化Meal() &#x2F;&#x2F;Meal类构造函数Cheese() &#x2F;&#x2F;Lunch类成员cheese初始化Lunch() &#x2F;&#x2F;Lunch类构造函数Lettuce() &#x2F;&#x2F;PortableLunch类成员lettuce初始化PortableLunch() &#x2F;&#x2F;PortableLunch类构造函数Banana() &#x2F;&#x2F;SandWich类成员banana初始化SandWich() &#x2F;&#x2F;SandWich类构造函数","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/tags/JavaSE/"}]},{"title":"MySQL索引及底层实现","slug":"mysql索引原理","date":"2020-01-18T14:33:23.906Z","updated":"2020-01-18T16:25:43.415Z","comments":true,"path":"2020/01/18/mysql索引原理/","link":"","permalink":"http://yoursite.com/2020/01/18/mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/","excerpt":"","text":"MySQL索引及底层实现一、什么是索引 “A database index is a data structure that improves the speed of operations in a table”–MySQL Tutorial 将以上索引定义翻译成中文，即 索引是用来提高操作数据表速度的数据结构 二、为什么要使用索引&emsp;&emsp;在对数据表进行查询时，若所查询的列没有定义索引，MySQL则会进行顺序查找，那么若数据规模为N，查找的时间复杂度为$O(N)$。在数据规模较大时，$O(N)$的时间是达不到所预期的查找效率的，若有千万级的数据需要查询时，可能查询几十秒都是有可能的。因此，使用索引的目的就是为了加快查询速度。 三、MySQL索引的数据结构&emsp;&emsp;在MySQL中，索引采用B+树的数据结构进行组织。下面与几种常见的数据结构做对比，来分析为什么要用B+树，而不是其它数据结构。 二叉搜索树若采用二叉搜索树对一列数据建立索引整体上的确能提高搜索的效率，但在一些特殊数据上(递增，或递减)，二叉搜索树的高度逐渐增加，导致其搜索效率逐渐低下，接近于顺序查找甚至有可能完全退化成链表，查询效率退化成顺序查询 二叉平衡树&emsp;&emsp;既然高度会对搜索效率影响，那使用平衡树（AVL，红黑树等）是不是就能更好的解决问题了呢？答案是肯定的，平衡树可以很好的控制整棵树的高度在$O(log_2(N))$的数量级上，进而将查询效率控制在接近二分查找的效率。&emsp;&emsp;但是，为什么MySQL不采用这种方式组织索引呢？我们想，数据库中文件可以基本分为“数据表”，“数据文件”，“索引文件”，这三种文件没有人会把他们都存放在内存里。实际上，它们是存放在磁盘中的（innoDB将索引文件和数据文件存放在一起，即.ibd文件，MyISAM数据文件存放在.MYD中，索引文件存放.MID中）。数据规模较大时，平衡树的高度能达到20余层，由于数据存放在磁盘中，因此在进行数据比较时需要先进行磁盘I/O从磁盘中读取节点数据到内存中，再进行比对。由于磁盘读写是以块为单位的，一个节点显然很难达到一个块那么大，更别要求整个块都是节点数据了。因此20余层平衡树需要做至多20余次磁盘I/O。从下图中可以看出，一次磁盘读取速度要比一次内存读取速度慢上至少50倍，这对于数据库查找的开销实在是太大了。因此要想办法减少磁盘I/O次数。 图1 磁盘与RAM读写性能 B树&emsp;&emsp;B树相比于二叉平衡树来说，其每一个节点都可以存放多个数据元素，如下图。相比于二叉平衡树来说，B树可以一次性读取一个节点，存满整个磁盘块。在Windows操作系统上，每个磁盘块的大小为4KB(4096Bytes)，MySQL中，定义一个索引节点大小为16KB(16384Bytes)，因此一次磁盘I/O可以读取整整4个磁盘块。再继续分析，由于每一个节点包含许多数据元素，因此可以有效减少树的高度，从而有效减少磁盘I/O次数。&emsp;&emsp;B树相比于二叉平衡树又有了性能上的改进，那为什么还要用B+树呢，B树相比于B+树，又有哪些性能上还可以提高的点呢？&emsp;&emsp;我们来继续看这张图，B树的每一个节点中，包含一个数字和一个data，其中数字就是索引项，data就是本条索引项所对应的所有数据（除所索引项）。换句话说，它们一起构成了数据表中的一个记录。我们可以知道，当一个数据库的某些数据表中，可能存在许多的数据列，因此一个记录就要占很大的空间，我们保守平均按1KB来算，忽略节点中的指针域，每个节点最多也就存放16个数据。对于百万，千万级的数据来讲，其树高也达到了$O(log_{16}(N))$。可以发现，树的高度相对来说还是没有很好的控制（相比于B+树）。因此有必要引入B+树了 图2 B树示意图 四、为什么要使用B+树作为索引的数据结构&emsp;&emsp;如下图（以InnoDB引擎为例），我们可以看到，首先，B+树中只有叶子节点存放data，且不存放指针。这样做，可以将B+树每个节点中存放更多的索引项，进而控制的树的高度。我们可以计算一下，按照一个索引项4B，一个指针域6B，每一个非叶节点就可以存放$16384/(4+6)=1638$个索引项，每一个叶子节点按1KB来算，可以存放16个项。因此若B+树为3层，总共可以存放$1638163816=42,928,704$个数据，已经可以满足千万级别的数据了。事实上，MySQL中B+树的层数可以控制到小于4层的，进而很好的控制了磁盘I/O次数。&emsp;&emsp;其次，我们可以发现，B+树的叶子节点之间是有指针连接点(图片上是单向指针，实际上是双向指针)。这样做的好处是可以解决范围查询，如select salary from T where salary &gt; 10000，MySQL先查找到不大于10000的第一个元素，进而通过叶子节点的指针一直遍历到最后一个元素。 图3 B+树（InnoDB聚集索引）示意图 五、聚集索引和非聚集索引&emsp;&emsp;InnoDB采用支持聚集索引的实现方式，MyISAM只采用非聚集索引的实现方式。它们两者的区别在于，InnoDB将data存放在B+树的叶子节点中，而MyISAM将data存放在单独的一个.MYD文件中，B+树的叶子节点中存放访问data的指针。相比较而言，聚集索引的速度比较快，因为它可以直接找到目标data元素，而非聚集索引需要进行额外的磁盘I/O寻找相应的数据位置。 图4 MyISAM存储引擎示意图","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL索引","slug":"MySQL索引","permalink":"http://yoursite.com/tags/MySQL%E7%B4%A2%E5%BC%95/"}]},{"title":"JDK动态代理实现与原理","slug":"JDK动态代理","date":"2020-01-16T03:44:02.283Z","updated":"2020-01-23T09:10:46.519Z","comments":true,"path":"2020/01/16/JDK动态代理/","link":"","permalink":"http://yoursite.com/2020/01/16/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"JDK动态代理实现与原理一、代理模式&emsp;&emsp;代理模式(Proxy Pattern) 是程序设计中的一种设计模式，结构如下图。代理类为委托（实现）类提供代理，以控制对委托类对象的访问。代理类负责为委托类预处理消息，过滤并转发消息，以及进行消息被委托类执行后的后续处理。&emsp;&emsp;为了保持行为的一致，代理类和委托类通常实现同样的接口，通过代理类可以对委托类对象进行访问，也可以隐藏和保护委托类对象。 avatar 图1 代理模式的结构示意图 图2 代理模式的UML图 二、JDK动态代理使用Java中的动态代理，需要使用以下两个类/接口。 interface InvocationHandler 该接口中只定义了一个方法： public object invoke(Object obj, Method method, Object[] args); obj:指代理类对象， method:指被代理的方法 args:该代理方法method的参数 class Proxy 该类为动态代理类，包含以下成员函数; protected Proxy(InvocationHandler h) 构造函数 static Class getProxyClass (ClassLoader loader, Class[] interfaces) 获得一个代理类加载器 loader:代理类的类加载器 interfaces:代理类实现的接口类型数组 static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 返回代理类的一个实例。使用委托类的引用指向此实例，即可通过invoke调用委托类在接口中声明过的方法。 loader:需要代理的类的类加载器 interfaces:需要代理的类所实现的接口 h:实现InvocaionHandler接口的类的实例，代理类对象将通过invoke来调用委托类方法以及其增强功能。 因此，在使用动态代理时，必须实现InvocationHandler接口，也就是实现其中的invoke方法,然后通过Proxy类中的静态方法newProxyInstance创建一个代理类实例， 三、使用方法（基于AOP）首先，创建一个ICustomerDao接口 12345678package com.lrq.AOP;public interface ICustomerDao &#123; public void add(); public void delete(); public void update(); public void find();&#125; 接着对此接口进行实现 12345678910111213141516171819package com.lrq.AOP;/** * CustomerDao类，实现了ICustomerDao接口中的add,delete,update,find方法 */public class CustomerDao implements ICustomerDao &#123; public void add()&#123; System.out.println(\"add...\"); &#125; public void delete()&#123; System.out.println(\"delete...\"); &#125; public void update()&#123; System.out.println(\"update...\"); &#125; public void find()&#123; System.out.println(\"find...\"); &#125;&#125; 创建一个切面类Aspect（用于增强CustomerDao功能） 1234567891011121314package com.lrq.AOP;/** * 切面类，用于对CustomerDao类的功能增强 * */public class Aspect &#123; public void before()&#123; System.out.println(\"before execute\"); &#125; public void after()&#123; System.out.println(\"after execute\"); &#125;&#125; 最后基于Spring IOC的思想，创建一个工厂类BeanFactory作为代理类，用切面类Aspect对CustomerDao功能进行增强（可以理解为，CustomerDao为委托类，代理类中增加了Aspect类中的功能） 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.lrq.AOP;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class BeanFactory &#123; static CustomerDao customerDao = new CustomerDao(); static Aspect aspect = new Aspect(); /** * * @return 代理类对象 */ public static ICustomerDao getBean()&#123; return (ICustomerDao) Proxy.newProxyInstance( /* 获取委托类的类加载器和实现的接口 */ CustomerDao.class.getClassLoader(), CustomerDao.class.getInterfaces(), /* 使用匿名内部类实现InvocationHandler接口 */ new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /* aspect.before()和aspect.after()是用来增强的功能 */ aspect.before(); /* 调用method.invoke，第一个参数是委托类对象*/ Object returnValue = method.invoke(customerDao, args); aspect.after(); return returnValue; &#125; &#125;); /* jdk8之后可以使用lambda表达式功能，使得代码更简介 其中实现InvocationHandler()接口的内部类可以用如下方式替换 (proxy, method, args) -&gt; &#123; aspect.before(); Object returnValue = method.invoke(customerDao, args); aspect.after(); return returnValue; &#125; */ &#125;&#125; 创建测试类进行测试 12345678910111213141516package com.lrq.AOP;import org.junit.Test;import static org.junit.Assert.*;public class AOPTest &#123; @Test public void test()&#123; ICustomerDao customerDao = BeanFactory.getBean(); customerDao.add(); customerDao.delete(); customerDao.find(); customerDao.update(); &#125;&#125; 输出结果如下 before executeadd…after executebefore executedelete…after executebefore executefind…after executebefore executeupdate…after execute 可见在add, delete, find, update函数前后都添加了增强功能 四、动态代理的实现动态代理实现的关键在于: Proxy.newProxyInstance(loader, interface, handler); 调用这个方法后，委托类引用会指向代理对象，当其调用真实的方法时，会自动跳转至代理对象关联的handler中的invoke方法中，进行调用。也就是说，当调用customerDao.add()方法时，会自动去调用实现InvocationHandler接口的类中的invoke方法（在上面是通过匿名内部类实现的） 参考文章：https://blog.csdn.net/jiankunking/article/details/52143504","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"jdk动态代理","slug":"jdk动态代理","permalink":"http://yoursite.com/tags/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"},{"name":"Spring AOP实现原理","slug":"Spring-AOP实现原理","permalink":"http://yoursite.com/tags/Spring-AOP%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"}]},{"title":"Java内存区域与内存溢出异常day02","slug":"JVM自动内存管理day02","date":"2020-01-11T16:12:03.169Z","updated":"2020-01-23T09:12:00.155Z","comments":true,"path":"2020/01/12/JVM自动内存管理day02/","link":"","permalink":"http://yoursite.com/2020/01/12/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day02/","excerpt":"","text":"Java虚拟机——自动内存管理第二章 Java内存区域与内存溢出异常 2.3 HotSpot 虚拟机对象探秘2.3.1 对象的创建在JVM中，一个对象（普通JAVA对象）被创建过程如下： 当Java虚拟机遇到一条字节码new指令时，首先检查此参数是否能在常量池中定位到一个类的符号引用 检查符号引用代表的类是否已经被加载、解析和初始化过，若没有则执行类加载过程。 给新生对象在Java堆中分配内存 并发时采用CAS与失败重试来保证分配内存时的线程安全。 对将生成的对象进行必要的设置（哪个类的实例，如何找到类的Meta Data，对象的HashCode等） &emsp;&emsp;Java堆如果是绝对规整的，即通过一个指针将空闲内存和可用内存分开，那么则通过指针碰撞(Bump The Pointer)来分配内存。如果Java堆是不规整的，即空闲内存和可用内存交错在一起，那么则采用空闲列表(Free List)来分配内存。[注]选择哪种方式是由Java堆是否规整来决定的，而Java堆是否规整又由GC是否带有空间压缩整理(Compact)的能力决定。因此，当使用Serial, ParNew等带压缩整理的收集器，则采用指针碰撞；当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用复杂的空闲列表来分配内存。 &emsp;&emsp;并发时，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，因此在并发情况下，有两种方案可以保证线程安全： 需要使用CAS(Compare and Swap)配上失败重试的方式来保证更新操作的原子性 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存即TLAB(Thread Local Allocation Buffer)，哪个线程要分配内存，就在哪个线程的本地缓冲区分配，只用本地缓冲区用完了，分配新的缓冲区时才需要同步锁定。 在虚拟机的视角中，对象已经建立完成，而在Java程序的视角来看，对象创建才刚刚开始——构造函数，Class文件中的&lt;init&gt;()方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。一般来说new指令之后就会接着执行&lt;init&gt;()方法，按程序员的意愿对对象进行初始化。 2.3.2 对象的内存布局在HotSpot虚拟机中，对象在堆内存中的存储布局可以划分为三个部分： 对象头(Header) 实例数据(Instance Data) 对齐填充(Padding) 首先，对于对象头包含了两部分信息。 用于存储对象自身的运行时数据如HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分在32位和64位虚拟机中分别为32bit和64bit，称为Mark Word 类型指针类型指针即对象指向它类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例（并不一定所有虚拟机实现都保留此指针）。 长度数据（Java数组）若对象是一个Java数组，则在对象头中还必须有一块记录数组长度的数据。 实例数据是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型字段内容，无论是从父类继承下来的，还是在子类中定义的。 对其填充并不是必然存在的，也没有特别的含义，仅仅起占位符的作用。HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是任何对象的大小都必须是8字节的整数倍。（对象头已经被精心设计成正好是8字节的倍数） 2.3.3对象的访问定位创建对象自然是为了后续使用该对象。 Java虚拟机规范称，Java程序会通过栈上的reference数据来操作堆上的具体对象。 由于知识定义了reference是一个指向对象的引用，并没有定义这个引用还应该通过什么方式区定位、访问堆中的具体位置，因此实现由虚拟机而定。主流的实现方式有以下两种：1.句柄访问Java堆中划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例与类型数据各自具体的地址信息优势：reference中存储的是稳定句柄地址，在对象被移动时指挥改变句柄中的实例数据指针，refenence本身不需要更改2.直接指针访问Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果知识访问对象本身的话，就不需要多一次间接访问的开销。优势：速度更快，节省了一次指针定位的时间开销[注]在HotSpot虚拟机中，主要使用直接指针访问的方式进行对象访问（有例外情况，如果使用了Shenandoah收集器可能会有一次额外的转发），但从整个软件开发的范围来看，在各种语言、框架中使用句柄来访问的情况十分常见","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"Java内存区域与内存溢出异常day01","slug":"JVM自动内存管理day01","date":"2020-01-10T15:44:14.194Z","updated":"2020-01-23T09:11:51.715Z","comments":true,"path":"2020/01/10/JVM自动内存管理day01/","link":"","permalink":"http://yoursite.com/2020/01/10/JVM%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86day01/","excerpt":"","text":"Java虚拟机——自动内存管理第二章 Java内存区域与内存溢出异常 2.2 运行时数据区域2.2.2 Java虚拟机栈（VM Stack） Java虚拟机栈是线程私有的。 虚拟机栈的“栈”更多情况下指的是其局部变量表部分。 局部变量表中存放了编译期可知的Java虚拟机基本数据类型(int, long, double…)，它们以局部变量槽(Slot)来表示，其中64位长度的long和double类型的数据会占用两个变量槽，其余的数据类型只占用一个 StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度。OutOfMemoryError异常：若Java虚拟机栈空间可以动态扩展，栈扩展时无法申请到足够的内存时发生。 [注]虚拟机真正使用多大内存空间（一个slot占用32bit或64bit）来实现一个变量槽，这是完全由具体的虚拟机自行决定的事情。 2.2.3 本地方法栈（Native Method Stacks） 与VM Stack发挥的作用非常相似，VM Stack为虚拟机执行Java方法（字节码）服务，本地方法则是为本地方法（Native）服务 2.2.4 Java堆（Java Heap） 为所有Java线程共享的一片区域 几乎所有对象实例都在堆中分配内存 是垃圾收集器管理的内存区域，因此也被称为GC堆(Garbage Collected Heap) Java堆既可以被实现成固定大小的，也可以是可扩展的。在当前主流Java虚拟机中都是按照可扩展来实现的（通过-Xmx和-Xms设定）。如果Java堆中没有内存完成实例分配，并且堆再也无法扩展时，Java虚拟机将会抛出OutOfMemoryError异常 2.2.5 方法区（Method Area）（非堆） 为所有Java线程共享的内存区域 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据， 一般方法区不进行内存回收，若回收，主要是针对常量池的回收和堆类型的卸载，但结果往往比较难令人满意，尤其是堆类型的卸载，条件十分苛刻（但是还是有必要的）。 《Java虚拟机规范》规定，如果方法去无法满足新的内存分配需求，将抛出OutOfMemoryError异常 2.2.6 运行时常量池（Runtime Constant Pool） 是方法区的一部分 Class文件中除了有类的模板、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载之后存放到方法区的运行时常量池中。 与Class文件常量池的区别：运行时常量池具备动态性，Java语言的常量不一定只有编译期才能产生，并非预置入Class文件中的常量池的内容才能进入运行时常量池，运行期间也可以将新的常量放入池中。 既然RCP是方法区的一部分，因此常量池无法再申请到内存时，会抛出OutOfMemoryError异常 2.2.7 直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，但是这部分的内存频繁的使用，也可能导致OutOfMemoryError异常出现。 JDK 1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"mybatis环境搭建","slug":"day01_mybatis环境搭建","date":"2020-01-10T03:21:05.000Z","updated":"2020-01-23T09:11:39.301Z","comments":true,"path":"2020/01/10/day01_mybatis环境搭建/","link":"","permalink":"http://yoursite.com/2020/01/10/day01_mybatis%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"mybatis环境搭建 mybatis环境搭建步骤 创建maven工程并导入坐标 创建实体类和dao接口 创建mybatis的主配置文件SqlMapConfig.xml 创建映射配置文件IUserDao.xml mybatis环境搭建注意事项 创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。在mybatis中它把持久层的操作接口名称和映射文件叫做Mapper。因此 IUserDao 和 IUserMapper是一样的 在IntelliJ Idea中创建目录的时候，它和包是不一样的。包在创建时，com.lrq.dao是三级结构，但目录在创建时，是一级结构 mybatis的映射配置文件位置必须和dao接口的包结构相同（因此我们需要分三级创建目录，保证IUserMapper(Dao).xml文件所在结构和Dao.java所在结构相同） 映射文件的mapper标签的namspace属性的取值必须是dao接口的全限定类名 映射配置文件的操作配置（select或其他)，id的属性取值必须是dao接口的方法名 当我们遵循了3, 4, 5点之后，在开发中就无须再去写dao的实现类","categories":[{"name":"Java学习","slug":"Java学习","permalink":"http://yoursite.com/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"小鸡你别生气了，大狗错了啵啵啵","slug":"小鸡你别生气了，大狗错了啵啵啵","date":"2020-01-08T17:00:27.000Z","updated":"2020-01-08T17:00:27.359Z","comments":true,"path":"2020/01/09/小鸡你别生气了，大狗错了啵啵啵/","link":"","permalink":"http://yoursite.com/2020/01/09/%E5%B0%8F%E9%B8%A1%E4%BD%A0%E5%88%AB%E7%94%9F%E6%B0%94%E4%BA%86%EF%BC%8C%E5%A4%A7%E7%8B%97%E9%94%99%E4%BA%86%E5%95%B5%E5%95%B5%E5%95%B5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Third","slug":"Third","date":"2020-01-08T16:53:00.000Z","updated":"2020-01-08T16:53:00.208Z","comments":true,"path":"2020/01/09/Third/","link":"","permalink":"http://yoursite.com/2020/01/09/Third/","excerpt":"","text":"","categories":[],"tags":[]}]}